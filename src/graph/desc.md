[toc]

# [图](https://leetcode.cn/leetbook/read/graph/r3cr3r/)
##「图」的类型
「图」的类型有很多，本 Leetbook 中我们将介绍三种类型的图：无向图、有向图、加权图。

### 无向图
「无向图」的图中任意两个顶点之间的边都是没有方向的。
### 有向图
「有向图」的图中任意两个顶点之间的边都是有方向的。
### 有权图
「加权图」的图中的每条边都带有一个相关的权重
### 「图」的定义和相关术语
* 顶点：在「图 1. 小A的朋友交际图」中，小 A 、小 B 、小 C 等均称为「图」的顶点。
* 边：顶点之间的连接线称为边。在「图 1. 小A的朋友交际图」中，小 A 和小 B 之间的连接线就是图中的一条边。
* 路径：从一个顶点到另一个顶点之间经过的所有顶点的集合。在「图 1. 小A的朋友交际图」中，从小 A 到小 C 的路径为[小A, 小B, 小C] 或者[小A, 小G, 小B, 小C]或者[小A, 小E, 小F, 小D, 小B, 小C]。
* 路径长度：一条路径上经过的边的数量。在「图 1. 小A的朋友交际图」中，从小 A 到小 C 的路径长度为2或者3或者5。
环：起点和终点为同一个顶点的路径。在「图 1. 小A的朋友交际图」中，[小A, 小B, 小D, 小F, 小E]组成了一个环。同理，[小A, 小G, 小B]也组成了一个环。
* 负权环：在「加权图」中，如果一个环的所有边的权重加起来为负数，我们就称之为「负权环」。在「图4. 负权环」中，它的所有边的权重和为-3。
* 连通性：两个不同顶点之间存在至少一条路径，则称这两个顶点是连通的。在「图 1. 小A的朋友交际图」中，小 A 和小 C 是连通的，因为它们之间至少有一条路径。
* 顶点的度：「度」适用于无向图，指的是和该顶点相连接的所有边数称为顶点的度。在「图 1. 小A的朋友交际图」中，顶点小A的度为3，因为与它相连接的边有3条。
* 顶点的入度：「入度」适用于有向图，一个顶点的入度为dd，则表示有dd条与顶点相连的边指向该顶点。在「图 2. 有向图的示例图」中，A的入度为1，由F指向A的边。
* 顶点的出度：「出度」适用于有向图，它与「入度」相反。一个顶点的出度为dd，则表示有dd条与顶点相连的边以该顶点为起点。在「图 2. 有向图的示例图」中，A 的出度为3，分别为，A 指向 B 的边，A 指向 C 的边，和 A 指向 G 的边。

## 「图」的存储
![img.png](img.png)
###  1.邻接矩阵   adjacent matrix
二维数组存图， 下标代表点，值代表连边 n * n
#### 存储示例
boolean[n][n]  boolean[i][j]==true表示存在i->j边 boolean[i][j]==false, 表示不存在i->j边
boolean[i][j] == boolean[j][i] == true 无向图需要2条边
```
[false, false, true, false, true, true]
[false, false, false, false, true, true]
[false, false, false, true, true, false]
[false, false, false, false, false, false]
[false, false, false, false, false, true]
[false, false, false, false, false, false]
```
int[][]   int[i][j]==3 表示存在i->j边的权值是3
```
[0, 0, 2, 0, 3, 5]
[0, 0, 0, 0, 3, 4]
[0, 0, 0, 5, 5, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 5]
[0, 0, 0, 0, 0, 5]
```

#### 基本操作
* 1.添加一条边：
> 如果我们想添加一条从 ii 连向 jj 的边，我们只需要将 con[i][j] 的值设置为 true 即可，因此添加一条边的时间复杂度为 Θ(1) 。

* 2.判断两个点之间是否有边相连：
> 如果我们想要知道图中是否存在一条从 ii 连向 jj 的边，只需要判断 con[i][j] 的值是否为 true 即可，如果 con[i][j] 的值为 true 说明存在连边，否则不存在。因此判断两个点之间是否有边相连的时间复杂度为 Θ(1) 。

* 3.遍历一个点的所有出边：
> 对于点 ii ，我们并不能直接知道 ii 与哪些点有连边，ii 与哪些点没有连边，因此需要遍历其他所有点 jj ，判断 ii 与 jj 之间是否有连边，如果有，再进行其他操作。因此，遍历一个点的所有出边的复杂度为 Θ(n) 。 

#### 劣势
矩阵存图法各种操作的时间复杂度相对来说都较为优秀，但是其劣势在于：存下一个图需要 O(n^2) 的空间复杂度，这在面对点与点之间的连边数远远小于 Θ(n^2) 的稀疏图时，就有很多空间被浪费了。

### 2.邻接表  adjacent list
利用 n 个链表，第 i 个链表里存着所有从 i 直接连向的点.
链表可以手打，也可以使用语言自带库进行模拟，如 C++ 的 vector, Python 和 Java 的 List
将链表的结点定义为一个结构体，这样不仅可以储存边连向的点的信息，还可以自由地加入其他信息，如边权等。如下所示：
```
struct node {
int nxt; // 连向的点
int val; // 边权
};
```

#### 存储示例
LinkedList<Node>[]  adj = new LinkedList<Node>[n];(n is the number of node)
adj[0],adj[1],adj[i] is linkedList saving the nodes connected with node i.
```
[1,3,5,6]  // LinkedList<Node>
[2,5,6]
[3,4,5]
[5,6]
```
#### 基本操作
* 1.添加一条边：
> 如果我们想添加一条从 i 连向 j 的边，我们需要往第 i 个链表之后插入一个新的结点，储存 i 连向 j 的边的相关信息。新建一个结构体，并且插入链表中，时间复杂度为 Θ(1) 。注意，如果我们添加的是无向边，那么需要添加两次。以 C++ 的 vector 为例，添加一条边的代码如下：

* 2.判断两个点之间是否有边相连
> ：如果我们想要知道图中是否存在一条从 i 连向 j 的边，那么我们需要遍历点 i 的所有出边，判断终点是否为 j 。如果遍历的过程中，发现一条出边其终点为 j ，说明存在一条 i 连向 j 的边，否则不存在对应的边。因此，判断两个点之间是否有边相连的时间复杂度，与遍历一个点的所有出边的时间复杂度相同，为Θ(出度)

* 3.遍历一个点的所有出边：
> 在时间复杂度上，遍历一个点的出边，假设这个点的出度为 d 那么其对应的链表长度为 d ，需要”看“ dd 个节点，因此时间复杂度为 Θ(出度)。从实现上来看，遍历一个点的所有出边，等价于遍历第 ii 个节点对应的链表。以 C++ 的 vector 为例，代码如下 

### 3.链式前向星存图法
链式前向星存图和邻接表存图的方式总体思路是相同的，只是在实现的方式上有所不同。链式前向星更像是数组模拟链表的一种运用。

## 图的算法
### 图的数据结构：并查集

### 图的深度优先算法
https://leetcode.cn/leetbook/read/dfs/euoui2/
#### 遍历图
取当前节点的邻居节点，入栈。入栈前检查是否已经访问，已访问过的不入栈

#### 遍历两点之间的所有路径

> 时间复杂度
O((2^V)*(V+E))
V 表示顶点数，E 表示边数。 
> 空间复杂度
O((2^V)*V)


### 图的广度优先算法
#### 遍历图

#### 遍历两点之间的所有路径，寻找最小值
「无权图」的最短路径
由于 图中存在环，和深度优先遍历一样，广度优先遍历也需要在遍历的时候记录已经遍历过的结点。特别注意：将结点添加到队列以后，一定要马上标记为「已经访问」，否则相同结点会重复入队

「带权图」
带权有向图、且所有权重都非负的单源最短路径问题：使用 Dijkstra 算法；
带权有向图的单源最短路径问题：Bellman-Ford 算法；
一个图的所有结点对的最短路径问题：Floy-Warshall 算法。

> 时间复杂度 O(V+E) V 表示顶点数，E 表示边数。
> 空间复杂度 O(V) V 表示顶点数。
