package com.stack;

import java.util.Stack;

public class LongestSubString {

    //    question32
//    总结：两种索引会入栈
//    等待被匹配的左括号索引。
//    充当「参照物」的右括号索引。因为：当左括号匹配光时，栈需要留一个垫底的参照物，用于计算一段连续的有效长度。
    int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();//维护一个栈，存储左括号的下标。遍历s，每遇到一个右括号，就将它和左括号匹配，出栈。
        //存下标的作用是为了计算有效括号序列的长度。栈顶元素是一段序列的可能的前一位元素，随着匹配过程（出栈入栈）的变化而变化。序列的长度=当前下标-栈顶元素
        int res = 0;
        int temp = 0;
        st.push(-1); //在栈中预置 -1 作为垫底的“参照物”，当左括号匹配光时，栈需要留一个垫底的参照物，作为序列的前一位，用于计算一段连续有效括号的长度。例如，"()()...."中，栈中前一对两对括号被匹配完后，后来的元素会以-1为起始位置计算长度
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') { //遇到左括号，就把它的下标入栈，等待匹配
                st.push(i);
            } else if (s.charAt(i) == ')') {
                st.pop();//遇到右括号，和左括号进行匹配。
                if (st.empty()) { //此时，垫底的参照物也被弹出了栈，栈彻底没有了元素。
                    st.push(i); //此时相当于旧有的有效括号序列已经断掉，i作为新序列的参照物（前一位）。例如，"()())()",当遇到第五个括号时，前面的序列断掉，参照物更新为4，新序列的前一位就是第五个括号.

                } else {
                    temp = st.pop(); //这里的栈顶元素temp是序列可能的前一位，即参照物。这个参照物随着匹配的过程而变化。当有一对括号因为匹配成功被弹出时，有效括号序列发生了变化，参照物会向左移动。
                    //例如，"(()"中，右面的两个括号都被弹出之后，参照物就变成一开始的左括号。"()()"中，这两个括号被匹配完之后，参照物就是一开始的-1
                    res = Math.max(res, i - temp);//更新有效括号序列长度为"当前下标-序列的前一位"
                }
            }
        }
        return res;
    }


}
